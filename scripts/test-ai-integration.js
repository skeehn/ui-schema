#!/usr/bin/env node

/**
 * Test AI integration with UISchema
 * Tests the full flow: Prompt â†’ AI â†’ UISchema â†’ Render
 */

const fs = require("node:fs");
const path = require("node:path");

const colors = {
  reset: "\x1b[0m",
  green: "\x1b[32m",
  red: "\x1b[31m",
  yellow: "\x1b[33m",
  blue: "\x1b[34m",
};

function log(message, color = "reset") {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

let passed = 0;
let failed = 0;
const failures = [];

function test(name, fn) {
  try {
    fn();
    log(`âœ… ${name}`, "green");
    passed++;
  } catch (error) {
    log(`âŒ ${name}: ${error.message}`, "red");
    failed++;
    failures.push({ name, error: error.message });
  }
}

log("\nğŸ¤– Testing AI Integration", "blue");
log("=".repeat(50), "blue");

// Test 1: Mock AI Response â†’ UISchema Conversion
log("\nğŸ“ Test 1: Mock AI Response â†’ UISchema", "blue");
test("Parse AI-generated JSON schema", () => {
  const { UISchemaDocumentSchema } = require("@uischema/core");
  
  // Simulate what an AI would return
  const aiResponse = {
    schemaVersion: "0.1.0",
    root: {
      type: "Container",
      props: {
        ariaLabel: "AI Generated Dashboard"
      },
      children: [
        {
          type: "Text",
          props: {
            text: "Welcome to AI Dashboard",
            ariaLabel: "Dashboard title"
          }
        },
        {
          type: "Button",
          props: {
            text: "Get Started",
            ariaLabel: "Get started button"
          }
        }
      ]
    }
  };
  
  const result = UISchemaDocumentSchema.safeParse(aiResponse);
  if (!result.success) {
    throw new Error("Failed to parse AI-generated schema");
  }
  
  if (result.data.root.type !== "Container") {
    throw new Error("Invalid schema structure");
  }
});

// Test 2: Structured Output Format
log("\nğŸ“‹ Test 2: Structured Output Format", "blue");
test("Validate OpenAI structured output format", () => {
  const { UISchemaDocumentSchema } = require("@uischema/core");
  
  // Format that OpenAI structured outputs would return
  const structuredOutput = {
    schemaVersion: "0.1.0",
    root: {
      type: "Container",
      props: {
        ariaLabel: "Weather Dashboard",
        className: "dashboard"
      },
      children: [
        {
          type: "Card",
          props: {
            ariaLabel: "Temperature card"
          },
          children: [
            {
              type: "Text",
              props: {
                text: "72Â°F",
                ariaLabel: "Temperature"
              }
            }
          ]
        }
      ]
    },
    meta: {
      name: "Weather Dashboard",
      description: "Generated by AI"
    }
  };
  
  const result = UISchemaDocumentSchema.safeParse(structuredOutput);
  if (!result.success) {
    throw new Error("Structured output validation failed");
  }
});

// Test 3: Streaming JSONL Patches
log("\nğŸ“¡ Test 3: Streaming JSONL Patches", "blue");
test("Process streaming AI updates", () => {
  const { parseJSONLPatches, applyPatches } = require("@uischema/protocol");
  
  // Simulate AI streaming updates
  const initialSchema = {
    type: "Container",
    props: { ariaLabel: "Loading..." }
  };
  
  // Simulate patches from AI stream
  const jsonlStream = `{"op":"set","path":"/props/ariaLabel","value":"Dashboard"}
{"op":"add","path":"/children","value":{"type":"Text","props":{"text":"Hello","ariaLabel":"Greeting"}}}
{"op":"set","path":"/children/0/props/text","value":"Welcome"}`;
  
  const patches = parseJSONLPatches(jsonlStream);
  if (patches.length !== 3) {
    throw new Error("Failed to parse JSONL stream");
  }
  
  const updated = applyPatches(initialSchema, patches);
  if (!updated.children || updated.children.length === 0) {
    throw new Error("Patches not applied correctly");
  }
});

// Test 4: Coarse-to-Fine Generation
log("\nğŸ¨ Test 4: Coarse-to-Fine Generation", "blue");
test("Coarse layout â†’ Fine refinement", () => {
  const { generateLayoutSkeleton, applyPatches } = require("@uischema/compressed");
  
  // Stage 1: AI generates coarse layout
  const skeleton = generateLayoutSkeleton("Create a dashboard");
  
  // Stage 2: AI refines with patches
  const refinementPatches = [
    { op: "set", path: "/children/0/children/0/props/text", value: "Revenue" },
    { op: "set", path: "/children/0/children/1/props/text", value: "Users" }
  ];
  
  const refined = applyPatches(skeleton, refinementPatches);
  if (!refined || !refined.children) {
    throw new Error("Coarse-to-fine pipeline failed");
  }
});

// Test 5: Compressed Shorthand (Token Efficiency)
log("\nğŸ’¾ Test 5: Compressed Shorthand (Token Efficiency)", "blue");
test("AI generates shorthand â†’ Expand to full schema", () => {
  const { expandShorthand } = require("@uischema/compressed");
  
  // AI generates compact shorthand (3-5x fewer tokens)
  const aiShorthand = "c[ariaLabel:Dashboard][children:txt[text:Welcome]|btn[text:Start;ariaLabel:Start button]]";
  
  const expanded = expandShorthand(aiShorthand);
  if (!expanded || expanded.type !== "Container") {
    throw new Error("Shorthand expansion failed");
  }
  
  if (!expanded.children || expanded.children.length !== 2) {
    throw new Error("Children not expanded correctly");
  }
  
  // Verify token efficiency
  const shorthandLength = aiShorthand.length;
  const expandedLength = JSON.stringify(expanded).length;
  const ratio = expandedLength / shorthandLength;
  
  log(`   ğŸ“Š Token ratio: ${ratio.toFixed(2)}x (shorthand is ${(1/ratio*100).toFixed(0)}% of full JSON)`, "yellow");
});

// Test 6: Render AI-Generated Schema
log("\nğŸ­ Test 6: Render AI-Generated Schema", "blue");
test("Render schema from AI", () => {
  const { renderUISchema } = require("@uischema/react");
  const { UISchemaDocumentSchema } = require("@uischema/core");
  
  // AI-generated schema
  const aiSchema = {
    schemaVersion: "0.1.0",
    root: {
      type: "Container",
      props: {
        ariaLabel: "AI Generated UI"
      },
      children: [
        {
          type: "Text",
          props: {
            text: "Generated by AI",
            ariaLabel: "AI text"
          }
        }
      ]
    }
  };
  
  // Validate
  const validation = UISchemaDocumentSchema.safeParse(aiSchema);
  if (!validation.success) {
    throw new Error("AI schema validation failed");
  }
  
  // Render
  const element = renderUISchema(validation.data);
  if (!element) {
    throw new Error("Rendering failed");
  }
});

// Test 7: Event Handling from AI Interactions
log("\nğŸ”„ Test 7: Event Handling", "blue");
test("Handle events from AI-generated UI", () => {
  const { createUIInteraction } = require("@uischema/protocol");
  
  // Simulate user interaction on AI-generated UI
  const interaction = createUIInteraction(
    "Button",
    "onClick",
    { buttonId: "ai-btn-1", timestamp: Date.now() },
    "btn-1"
  );
  
  if (interaction.type !== "ui.interaction") {
    throw new Error("Event creation failed");
  }
  
  if (interaction.payload.componentType !== "Button") {
    throw new Error("Event payload incorrect");
  }
});

// Test 8: Spec Bridge Compatibility
log("\nğŸŒ‰ Test 8: Spec Bridge Compatibility", "blue");
test("Convert AI output from other specs", () => {
  const { fromOpenJSONUIDocument } = require("@uischema/bridges");
  
  // AI might return Open-JSON-UI format
  const aiOpenJSONUI = {
    version: "1.0",
    components: [
      {
        type: "container",
        properties: {
          title: "AI Dashboard"
        },
        children: [
          {
            type: "button",
            properties: {
              label: "Click me"
            }
          }
        ]
      }
    ]
  };
  
  const uischema = fromOpenJSONUIDocument(aiOpenJSONUI);
  if (!uischema || !uischema.root) {
    throw new Error("Bridge conversion failed");
  }
  
  if (uischema.root.type !== "Container") {
    throw new Error("Converted schema invalid");
  }
});

// Summary
log("\n" + "=".repeat(50), "blue");
log(`\nğŸ“Š AI Integration Test Results:`, "blue");
log(`âœ… Passed: ${passed}`, "green");
if (failed > 0) {
  log(`âŒ Failed: ${failed}`, "red");
  log("\nFailures:", "yellow");
  failures.forEach(({ name, error }) => {
    log(`  - ${name}: ${error}`, "red");
  });
} else {
  log(`âŒ Failed: ${failed}`, "green");
}

log("\n" + "=".repeat(50), "blue");

if (failed > 0) {
  log("\nâŒ Some AI integration tests failed", "red");
  process.exit(1);
} else {
  log("\nğŸ‰ All AI integration tests passed!", "green");
  log("\nğŸ’¡ Next: Test with real AI (see TESTING_WITH_AI.md)", "blue");
  process.exit(0);
}
